"""The `traceon.plotting` module uses the `vedo` plotting library to provide some convenience functions
to show the line and triangle meshes generated by Traceon."""

from math import sqrt
from scipy.interpolate import *
import numpy as np
import vedo

from . import backend

def _create_point_to_physical_dict(mesh):
    d = {}
    
    for k, v in mesh.cell_sets_dict.items():
        
        if 'triangle' in v: 
            for p in mesh.cells_dict['triangle'][v['triangle']]:
                a, b, c = p
                d[a], d[b], d[c] = k, k, k
        
        if 'line4' in v:
            for l in mesh.cells_dict['line4'][v['line4']]:
                a, b, c, e = l
                d[a], d[b], d[c], d[e] = k, k, k, k
     
    return d

def plot_triangle_mesh(mesh, show_legend=True, show_normals=False, **colors):
    
    dict_ = _create_point_to_physical_dict(mesh)
    triangles = mesh.cells_dict['triangle']
     
    triangles_to_plot = []
    colors_ = []
     
    for (A, B, C) in triangles:
        color = '#CCCCCC'
        
        if A in dict_ and B in dict_ and C in dict_:
            phys1, phys2, phys3 = dict_[A], dict_[B], dict_[C]
            if phys1 == phys2 and phys2 == phys3 and phys1 in colors:
                color = colors[phys1]
         
        triangles_to_plot.append( [A, B, C] )
        colors_.append(color)
    
    colors_, triangles_to_plot = np.array(colors_), np.array(triangles_to_plot)
    plotter = vedo.Plotter()
    meshes = []
    
    for c in set(colors_):
        mask = colors_ == c
        vm = vedo.Mesh([mesh.points, triangles_to_plot[mask]], c)
        vm.linecolor('black').linewidth(2)
        
        key = [k for k, col in colors.items() if c==col]
        if len(key):
            vm.legend(key[0])
        
        plotter += vm
        meshes.append(vm)
    
    if show_normals:
        normals = np.zeros( (len(triangles_to_plot), 6) )
        for i, t in enumerate(triangles_to_plot):
            v1, v2, v3 = mesh.points[t]
            middle = (v1 + v2 + v3)/3
            area = 1/2*np.linalg.norm(np.cross(v2-v1, v3-v1))
            side_length = sqrt( (4*area) / sqrt(3) ) # Equilateral triangle, side length with equal area
            normal = 0.75*side_length*backend.normal_3d(v1, v2, v3)
            normals[i] = [*middle, *(middle+normal)]
        
        arrows = vedo.shapes.Arrows(normals[:, :3], normals[:, 3:], res=20, c='black')
        plotter.add(arrows)
     
    lb = vedo.LegendBox(meshes)
    plotter.add(lb)
     
    plotter.show(viewup='z', axes={'xtitle': 'x (mm)', 'ytitle': 'y (mm)', 'ztitle': 'z (mm)'})


def plot_line_mesh(mesh, trajectory=None, show_legend=True, show_normals=False, **colors):
    """Show a 2D mesh (mesh consisting of many line elements).
    
    Parameters
    ---------
    mesh: meshio object
        The mesh to show.
    trajectory: (N, 2) np.ndarray
        Optionally also show a trajectory inside the geometry. The trajectory
        can simply be the position values returned when calling `traceon.tracing.Tracer`.
    show_legend: bool
        Whether to show a legend. The colors in the legend will correspond to the different physical
        groups present in the geometry.
    colors: dict
        The colors to use for the physical groups. The keys in the dictionary correspond to the
        physical group names, while the values can be any color understood by vedo.
    """
    dict_ = _create_point_to_physical_dict(mesh)
    lines = mesh.cells_dict['line4']
    
    start = []
    end = []
    colors_ = []
    
    for (P1, P2, P3, P4) in lines:
        for A, B in [(P1, P3), (P3, P4), (P4, P2)]:
            color = '#CCC'

            if A in dict_ and B in dict_:
                phys1, phys2 = dict_[A], dict_[B]
                if phys1 == phys2 and phys1 in colors:
                    color = colors[phys1]
            
            p1, p2 = mesh.points[A], mesh.points[B]
            start.append(p1)
            end.append(p2)
            colors_.append(color)

    start, end = np.array(start), np.array(end)
    colors_ = np.array(colors_)
    plotter = vedo.Plotter()
    lines = []
     
    for c in set(colors_):
        mask = colors_ == c
        l = vedo.Lines(start[mask], end[mask], lw=3, c=c)
        
        key = [k for k, col in colors.items() if c==col]
        if len(key):
            l.legend(key[0])
         
        plotter += l
        lines.append(l)
    
    lb = vedo.LegendBox(lines)
    plotter += lb
    
    if show_normals:
        normals = np.zeros( (len(start), 4) )
        
        for i, (v1, v2) in enumerate(zip(start, end)):
            v1, v2 = v1[:2], v2[:2]
            middle = (v1 + v2)/2
            normal = backend.normal_2d(v1, v2)
            length = np.linalg.norm(v2-v1)
            normal = 3*length*backend.normal_2d(v1, v2)
            normals[i] = [*middle, *(middle+normal)]
        
        arrows = vedo.shapes.Arrows(normals[:, :2], normals[:, 2:], c='black')
        plotter.add(arrows)
    
    plotter.show(axes={'xtitle': 'x (mm)', 'ytitle': 'y (mm)'})

'''
def show_charge_density(lines, charges):
    # See https://matplotlib.org/stable/gallery/lines_bars_and_markers/multicolored_line.html
    assert len(lines) == len(charges)

    plt.figure()
    segments = lines[:, :, :2] # Remove z value
    
    amplitude = np.mean(np.abs(charges))
    norm = plt.Normalize(-3*amplitude, 3*amplitude)
    
    lc = LineCollection(segments, cmap='coolwarm', norm=norm)
    lc.set_array(charges)
    lc.set_linewidth(4)
    line = plt.gca().add_collection(lc)
    plt.xlim(np.min(lines[:, :, 0])-0.2, np.max(lines[:, :, 0])+0.2)
    plt.ylim(np.min(lines[:, :, 1])-0.2, np.max(lines[:, :, 1])+0.2)
    plt.xlabel('r (mm)')
    plt.ylabel('z (mm)')
    plt.show()
'''


