#include <stdio.h>
#include <assert.h>
#include <math.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>

#ifdef _MSC_VER
#define EXPORT __declspec(dllexport)

#include <Python.h>
PyMODINIT_FUNC PyInit_traceon_backend(void) {
	return NULL;
}

#else
#define EXPORT extern
#endif

#if defined(__clang__)
	#define UNROLL _Pragma("clang loop unroll(full)")
#elif defined(__GNUC__) || defined(__GNUG__)
	#define UNROLL _Pragma("GCC unroll 100")
#else
	#define UNROLL
#endif


#define DERIV_2D_MAX 9
#define NU_MAX 4
#define M_MAX 8

// DERIV_2D_MAX, NU_MAX_SYM and M_MAX_SYM need to be present in the .so file to
// be able to read them. We cannot call them NU_MAX and M_MAX as
// the preprocessor will substitute their names. We can also not 
// simply only use these symbols instead of the preprocessor variables
// as the length of arrays need to be a compile time constant in C...
EXPORT const int DERIV_2D_MAX_SYM = 9;
EXPORT const int NU_MAX_SYM = NU_MAX;
EXPORT const int M_MAX_SYM = M_MAX;


#define TRACING_STEP_MAX 0.01
#define MIN_DISTANCE_AXIS 1e-10

#ifndef M_PI
    #define M_PI 3.14159265358979323846
#endif


EXPORT const size_t TRACING_BLOCK_SIZE = (size_t) 1e5;

#define N_QUAD_2D 4
EXPORT const int N_QUAD_2D_SYM = N_QUAD_2D;
const double GAUSS_QUAD_POINTS[N_QUAD_2D] = {-0.3399810435848563, 0.3399810435848563, -0.8611363115940526, 0.8611363115940526};
const double GAUSS_QUAD_WEIGHTS[N_QUAD_2D] = {0.6521451548625461, 0.6521451548625461, 0.3478548451374538, 0.3478548451374538};


//////////////////////////////// TYPEDEFS

typedef double (*integration_cb_2d)(double, double, double, double, void*);
typedef double (*vertices_2d)[4][3];
typedef double (*charges_2d)[N_QUAD_2D];

// See GMSH documentation
typedef double triangle6[6][3];
typedef double (*vertices_3d)[6][3];

//////////////////////////////// ELLIPTIC FUNCTIONS

// Chebyshev Approximations for the Complete Elliptic Integrals K and E.
// W. J. Cody. 1965.
//
// Augmented with the tricks shown on the Scipy documentation for ellipe and ellipk.


double ellipk_singularity(double k) {
	double eta = 1 - k;
	
	double A[] = {log(4.0),
			9.65736020516771e-2,
			3.08909633861795e-2,
			1.52618320622534e-2,
			1.25565693543211e-2,
			1.68695685967517e-2,
			1.09423810688623e-2,
			1.40704915496101e-3};
	
	double B[] = {1.0/2.0,
			1.24999998585309e-1,
			7.03114105853296e-2,
			4.87379510945218e-2,
			3.57218443007327e-2,
			2.09857677336790e-2,
			5.81807961871996e-3,
			3.42805719229748e-4};
	
	double L = log(1./eta);
	double sum_ = 0.0;

	for(int i = 0; i < 8; i++)
		sum_ += (A[i] + L*B[i])*pow(eta, i);
	
	return sum_;
}

EXPORT double ellipk(double k) {
	if(k > -1) return ellipk_singularity(k);
	
	return ellipk_singularity(1 - 1./(1-k))/sqrt(1-k);
}

double ellipe_01(double k) {
	double eta = 1 - k;
	
	double A[] = {1,
        4.43147193467733e-1,
        5.68115681053803e-2,
        2.21862206993846e-2,
        1.56847700239786e-2,
        1.92284389022977e-2,
        1.21819481486695e-2,
        1.55618744745296e-3};

    double B[] = {0,
        2.49999998448655e-1,
        9.37488062098189e-2,
        5.84950297066166e-2,
        4.09074821593164e-2,
        2.35091602564984e-2,
        6.45682247315060e-3,
        3.78886487349367e-4};
	
	double L = log(1./eta);
	double sum_ = 0.0;

	for(int i = 0; i < 8; i++)
		sum_ += (A[i] + L*B[i])*pow(eta, i);
		
	return sum_;
}

EXPORT double ellipe(double k) {
	if (0 <= k && k <= 1) return ellipe_01(k);

	return ellipe_01(k/(k-1.))*sqrt(1-k);
}


//////////////////////////////// UTILITIES 2D



EXPORT inline double
norm_2d(double x, double y) {
	return sqrt(x*x + y*y);
}

EXPORT inline double
length_2d(double *v1, double *v2) {
	return norm_2d(v2[0]-v1[0], v2[1]-v1[1]);
}

EXPORT void
normal_2d(double *p1, double *p2, double *normal) {
	double x1 = p1[0], y1 = p1[1];
	double x2 = p2[0], y2 = p2[1];
	
	double tangent_x = x2 - x1, tangent_y = y2 - y1;
	double normal_x = tangent_y, normal_y = -tangent_x;
	double length = norm_2d(normal_x, normal_y);

	normal[0] = normal_x/length;
	normal[1] = normal_y/length;
}

void
higher_order_normal_radial(double alpha, double *v1, double *v2, double *v3, double *v4, double *normal) {

	double v1x = v1[0], v1y = v1[1];
	double v2x = v2[0], v2y = v2[1];
	double v3x = v3[0], v3y = v3[1];
	double v4x = v4[0], v4y = v4[1];
		
	double a2 = pow(alpha, 2);
	double a3 = pow(alpha, 3);
	
	double dx = (2*alpha*(9*v4x-9*v3x-9*v2x+9*v1x)+3*a2*(9*v4x-27*v3x+27*v2x-9*v1x)-v4x+27*v3x-27*v2x+v1x)/16;
	double dy = (2*alpha*(9*v4y-9*v3y-9*v2y+9*v1y)+3*a2*(9*v4y-27*v3y+27*v2y-9*v1y)-v4y+27*v3y-27*v2y+v1y)/16;

	double zero[2] = {0., 0.};
	double vec[2] = {dx, dy};
	normal_2d(zero, vec, normal);
}


EXPORT void inline position_and_jacobian_radial(double alpha, double *v1, double *v2, double *v3, double *v4, double *pos_out, double *jac) {

	double v1x = v1[0], v1y = v1[1];
	double v2x = v2[0], v2y = v2[1];
	double v3x = v3[0], v3y = v3[1];
	double v4x = v4[0], v4y = v4[1];
		
	double a2 = pow(alpha, 2);
	double a3 = pow(alpha, 3);
	
	// Higher order line element parametrization. 
	pos_out[0] = (a2*(9*v4x-9*v3x-9*v2x+9*v1x)+a3*(9*v4x-27*v3x+27*v2x-9*v1x)-v4x+alpha*(-v4x+27*v3x-27*v2x+v1x)+9*v3x+9*v2x-v1x)/16;
	pos_out[1] = (a2*(9*v4y-9*v3y-9*v2y+9*v1y)+a3*(9*v4y-27*v3y+27*v2y-9*v1y)-v4y+alpha*(-v4y+27*v3y-27*v2y+v1y)+9*v3y+9*v2y-v1y)/16;
	
	// Term following from the Jacobian
	*jac = 1/16. * sqrt(pow(2*alpha*(9*v4y-9*v3y-9*v2y+9*v1y)+3*a2*(9*v4y-27*v3y+27*v2y-9*v1y)-v4y+27*v3y-27*v2y+v1y, 2) +pow(2*alpha*(9*v4x-9*v3x-9*v2x+9*v1x)+3*a2*(9*v4x-27*v3x+27*v2x-9*v1x)-v4x+27*v3x-27*v2x+v1x, 2));
}

//////////////////////////////// UTILITIES 3D


typedef double (*integration_cb_3d)(double, double, double, double, double, double, void*);

EXPORT inline double
norm_3d(double x, double y, double z) {
	return sqrt(x*x + y*y + z*z);
}

EXPORT void
normal_3d(double *p1, double *p2, double *p3, double *normal) {
	double x1 = p1[0], y1 = p1[1], z1 = p1[2];
	double x2 = p2[0], y2 = p2[1], z2 = p2[2];
	double x3 = p3[0], y3 = p3[1], z3 = p3[2];

	double normal_x = (y2-y1)*(z3-z1)-(y3-y1)*(z2-z1);
	double normal_y = (x3-x1)*(z2-z1)-(x2-x1)*(z3-z1);
	double normal_z = (x2-x1)*(y3-y1)-(x3-x1)*(y2-y1);
	double length = norm_3d(normal_x, normal_y, normal_z);
	
	normal[0] = normal_x/length;
	normal[1] = normal_y/length;
	normal[2] = normal_z/length;
}

void barycentric_coefficients_higher_order_triangle_3d(double alpha, double beta,
	double v0, double v1, double v2, double v3, double v4, double v5, double coeffs[6]) {
	//v3 = (v0+v1)/2.;
	//v4 = (v1+v2)/2.;
	//v5 = (v0+v2)/2.;
    coeffs[0] = v0;
	coeffs[1] = 4*v3-v1-3*v0;
	coeffs[2] = 4*v5-v2-3*v0;
	coeffs[3] = -4*v3+2*v1+2*v0;
	coeffs[4] = -4*v5+4*v4-4*v3+4*v0;
	coeffs[5] = -4*v5+2*v2+2*v0;
}

double dot6(double *v1, double *v2) {
	double sum = 0.0;
	for(int i = 0; i < 6; i++) sum += v1[i]*v2[i];
	return sum;
}

double norm_cross_product_3d(double *v1, double *v2) {
	double v1x = v1[0], v1y = v1[1], v1z = v1[2];
	double v2x = v2[0], v2y = v2[1], v2z = v2[2];
	return norm_3d(v1y*v2z-v1z*v2y,v1z*v2x-v1x*v2z,v1x*v2y-v1y*v2x);
}

EXPORT void position_and_jacobian_3d(double alpha, double beta, triangle6 v, double *pos_out, double *jac) {

	double coeffs_x[6], coeffs_y[6], coeffs_z[6];
	barycentric_coefficients_higher_order_triangle_3d(alpha, beta, v[0][0], v[1][0], v[2][0], v[3][0], v[4][0], v[5][0], coeffs_x);
	barycentric_coefficients_higher_order_triangle_3d(alpha, beta, v[0][1], v[1][1], v[2][1], v[3][1], v[4][1], v[5][1], coeffs_y);
	barycentric_coefficients_higher_order_triangle_3d(alpha, beta, v[0][2], v[1][2], v[2][2], v[3][2], v[4][2], v[5][2], coeffs_z);
	
	double monomials[6] = {1, alpha, beta, pow(alpha,2), alpha*beta, pow(beta,2)};
	double monomials_da[6] = {0, 1, 0, 2*alpha, beta, 0};
	double monomials_db[6] = {0, 0, 1, 0, alpha, 2*beta};

	pos_out[0] = dot6(coeffs_x, monomials);
	pos_out[1] = dot6(coeffs_y, monomials);
	pos_out[2] = dot6(coeffs_z, monomials);

	double da[3] = {
		dot6(coeffs_x, monomials_da),
		dot6(coeffs_y, monomials_da),
		dot6(coeffs_z, monomials_da),
	};
	
	double db[3] = {
		dot6(coeffs_x, monomials_db),
		dot6(coeffs_y, monomials_db),
		dot6(coeffs_z, monomials_db),
	};
	
	*jac = norm_cross_product_3d(da, db);
}

// Triangle quadrature constants
#define N_TRIANGLE_QUAD 9
const double QUAD_B1[N_TRIANGLE_QUAD] = {0.124949503233232, 0.437525248383384, 0.437525248383384, 0.797112651860071, 0.797112651860071, 0.165409927389841, 0.165409927389841, 0.037477420750088, 0.037477420750088};
const double QUAD_B2[N_TRIANGLE_QUAD] = {0.437525248383384, 0.124949503233232, 0.437525248383384, 0.165409927389841, 0.037477420750088, 0.797112651860071, 0.037477420750088, 0.797112651860071, 0.165409927389841};
const double QUAD_WEIGHTS[N_TRIANGLE_QUAD] = {0.205950504760887, 0.205950504760887, 0.205950504760887, 0.063691414286223, 0.063691414286223, 0.063691414286223, 0.063691414286223, 0.063691414286223, 0.063691414286223};

//const double QUAD_B1[N_TRIANGLE_QUAD] = {0.333333333333333333333333333333, 0.950275662924105565450352089520, 0.024862168537947217274823955239, 0.024862168537947217274823955239, 0.171614914923835347556304795551, 0.414192542538082326221847602214, 0.414192542538082326221847602214, 0.539412243677190440263092985511, 0.230293878161404779868453507244, 0.230293878161404779868453507244, 0.772160036676532561750285570113, 0.113919981661733719124857214943, 0.113919981661733719124857214943, 0.009085399949835353883572964740, 0.495457300025082323058213517632, 0.495457300025082323058213517632, 0.062277290305886993497083640527, 0.468861354847056503251458179727, 0.468861354847056503251458179727, 0.022076289653624405142446876931, 0.022076289653624405142446876931, 0.851306504174348550389457672223, 0.851306504174348550389457672223, 0.126617206172027096933163647918, 0.126617206172027096933163647918, 0.018620522802520968955913511549, 0.018620522802520968955913511549, 0.689441970728591295496647976487, 0.689441970728591295496647976487, 0.291937506468887771754472382212, 0.291937506468887771754472382212, 0.096506481292159228736516560903, 0.096506481292159228736516560903, 0.635867859433872768286976979827, 0.635867859433872768286976979827, 0.267625659273967961282458816185, 0.267625659273967961282458816185};
//const double QUAD_B2[N_TRIANGLE_QUAD] = {0.333333333333333333333333333333, 0.02486216853794721727482395523, 0.95027566292410556545035208952, 0.02486216853794721727482395523, 0.41419254253808232622184760221, 0.17161491492383534755630479555, 0.41419254253808232622184760221, 0.23029387816140477986845350724, 0.53941224367719044026309298551, 0.23029387816140477986845350724, 0.11391998166173371912485721494, 0.77216003667653256175028557011, 0.11391998166173371912485721494, 0.49545730002508232305821351763, 0.00908539994983535388357296474, 0.49545730002508232305821351763, 0.46886135484705650325145817972, 0.06227729030588699349708364052, 0.46886135484705650325145817972, 0.85130650417434855038945767222, 0.12661720617202709693316364791, 0.02207628965362440514244687693, 0.12661720617202709693316364791, 0.02207628965362440514244687693, 0.85130650417434855038945767222, 0.68944197072859129549664797648, 0.29193750646888777175447238221, 0.01862052280252096895591351154, 0.29193750646888777175447238221, 0.01862052280252096895591351154, 0.68944197072859129549664797648, 0.63586785943387276828697697982, 0.26762565927396796128245881618, 0.09650648129215922873651656090, 0.26762565927396796128245881618, 0.09650648129215922873651656090, 0.63586785943387276828697697982};
//const double QUAD_WEIGHTS[N_TRIANGLE_QUAD] = {0.051739766065744133555179145422, 0.00800779955556480159780412346, 0.00800779955556480159780412346, 0.00800779955556480159780412346, 0.04686889898182164482322673207, 0.04686889898182164482322673207, 0.04686889898182164482322673207, 0.04659094018397648796036177007, 0.04659094018397648796036177007, 0.04659094018397648796036177007, 0.03101694331379638140764622013, 0.03101694331379638140764622013, 0.03101694331379638140764622013, 0.01079161273663127362317824013, 0.01079161273663127362317824013, 0.01079161273663127362317824013, 0.03219553424243161881941448220, 0.03219553424243161881941448220, 0.03219553424243161881941448220, 0.01544583421070158381769290005, 0.01544583421070158381769290005, 0.01544583421070158381769290005, 0.01544583421070158381769290005, 0.01544583421070158381769290005, 0.01544583421070158381769290005, 0.01782298992317866188874831948, 0.01782298992317866188874831948, 0.01782298992317866188874831948, 0.01782298992317866188874831948, 0.01782298992317866188874831948, 0.01782298992317866188874831948, 0.03703868368138462791854647219, 0.03703868368138462791854647219, 0.03703868368138462791854647219, 0.03703868368138462791854647219, 0.03703868368138462791854647219, 0.03703868368138462791854647219};

EXPORT double
triangle_integral(double target[3], triangle6 vertices, integration_cb_3d function, void *args) {
	
	double sum_ = 0.0;
	
	for (int k=0; k < N_TRIANGLE_QUAD; k++) {
		double b1_ = QUAD_B1[k];
		double b2_ = QUAD_B2[k];
		double w = QUAD_WEIGHTS[k];
		
		double pos[3], jac;
		position_and_jacobian_3d(b1_, b2_, vertices, pos, &jac);
		
        sum_ += 0.5*w*jac*function(target[0], target[1], target[2], pos[0], pos[1], pos[2], args);
	}
	      
    return sum_;
}

#define N_SINGULAR_3D 256
const double QUAD_SINGULAR_WEIGHTS[N_SINGULAR_3D] = 
{1.1594084407543545e-25,1.0393960223776654e-21,1.3305441837137800e-19,3.4829853103476995e-18,3.8907169881170207e-17,2.5252679060022638e-16,1.1153708400991510e-15,3.6711184197017797e-15,9.5209638909715801e-15,2.0154262496870586e-14,
 3.5578763721322339e-14,5.2934150178559523e-14,6.6312353046216126e-14,6.8654044852216856e-14,5.5255684278074167e-14,2.7009109592593586e-14,1.0393960219068910e-21,9.3180630127401784e-18,1.1928172013511026e-15,3.1224553390176276e-14,
 3.4879819894904478e-13,2.2638729575231792e-12,9.9991683120377566e-12,3.2911144573904210e-11,8.5354320747883054e-11,1.8068059130296488e-10,3.1895942945047745e-10,4.7454842646150592e-10,5.9448244067187664e-10,6.1547543211590561e-10,
 4.9536070643927407e-10,2.4213348876021271e-10,1.3305440613536846e-19,1.1928170921969806e-15,1.5269404635843448e-13,3.9970947748577934e-12,4.4650100870223061e-11,2.8980125532571067e-10,1.2800062474406495e-09,4.2129974564289290e-09,
 1.0926315108809102e-08,2.3129152189651872e-08,4.0830402053059710e-08,6.0747547358773133e-08,7.6100452988443905e-08,7.8787792511319582e-08,6.3411753777116548e-08,3.0995815717448466e-08,3.4829736566588384e-18,3.1224448930369702e-14,
 3.9970817685961644e-12,1.0463220428667718e-10,1.1688085319018074e-09,7.5861459028961986e-09,3.3506804995685397e-08,1.1028390252167744e-07,2.8601884592696338e-07,6.0545328875055306e-07,1.0688200328887375e-06,1.5901924130342605e-06,
 1.9920864007230910e-06,2.0624330584290487e-06,1.6599335139907426e-06,8.1137944053269302e-07,3.8905277215557225e-17,3.4878123158254848e-13,4.4647932941778102e-11,1.1687555849483489e-09,1.3055746160644128e-08,8.4738254848865089e-08,
 3.7427545122901463e-07,1.2318858030454582e-06,3.1948684045853013e-06,6.7629934538486662e-06,1.1938861378861813e-05,1.7762659943435139e-05,2.2251869034180569e-05,2.3037650521217019e-05,1.8541677281347739e-05,9.0632158530908381e-06,
 2.5242678080420665e-16,2.2629763824971172e-12,2.8968651012589159e-10,7.5831668855832273e-09,8.4708816134856964e-08,5.4980214545064531e-07,2.4283890014283976e-06,7.9927708999031298e-06,2.0729073384935360e-05,4.3879925509752994e-05,
 7.7462199475824921e-05,1.1524840301737311e-04,1.4437546958099889e-04,1.4947380855669028e-04,1.2030285456929031e-04,5.8804320782851001e-05,1.1129751845491670e-15,9.9776915464991836e-12,1.2772570962620909e-09,3.3434949085277386e-08,
 3.7348973025077201e-07,2.4241332173589339e-06,1.0707012498480897e-05,3.5240934575316863e-05,9.1396579248168207e-05,1.9347102568368680e-04,3.4153866512310206e-04,5.0814185487215954e-04,6.3656603467094198e-04,6.5904512640711408e-04,
 5.3042744252204221e-04,2.5927419256812603e-04,3.6396065715360564e-15,3.2628644578547595e-11,4.1768346551047518e-09,1.0933762234693673e-07,1.2213710561503427e-06,7.9273027023979058e-06,3.5013640548306621e-05,1.1524348327618016e-04,
 2.9888140819805839e-04,6.3268114712315097e-04,1.1168859712889501e-03,1.6617050046936891e-03,2.0816725791990556e-03,2.1551827986010046e-03,1.7345824348350548e-03,8.4786801017751648e-04,9.2645063766737075e-15,8.3055209352640759e-11,
 1.0632003909202293e-08,2.7831554854458587e-07,3.1089623879907467e-06,2.0178704756319996e-05,8.9126143102177420e-05,2.9334873555623378e-04,7.6079341480898247e-04,1.6104703645069792e-03,2.8429988240890776e-03,4.2298188855170839e-03,
 5.2988334055010652e-03,5.4859514038380708e-03,4.4153261382901023e-03,2.1582218936240954e-03,1.8758828984664566e-14,1.6817069417260049e-10,2.1527746324312912e-08,5.6353501920687092e-07,6.2950459943459982e-06,4.0857964392890814e-05,
 1.8046315783494131e-04,5.9397430790508136e-04,1.5404591438345676e-03,3.2608902109152091e-03,5.7565213489374628e-03,8.5645630628847051e-03,1.0729110179285167e-02,1.1107987842923508e-02,8.9401792790865433e-03,4.3699808459724074e-03,
 3.0238213438913996e-14,2.7108202482780688e-10,3.4701557796893053e-08,9.0838784259989679e-07,1.0147272227942784e-05,6.5860819404120832e-05,2.9089680858727419e-04,9.5745432267376862e-04,2.4831364699404398e-03,5.2563779049922682e-03,
 9.2791997494692594e-03,1.3805610473780733e-02,1.7294742858206771e-02,1.7905473073280376e-02,1.4411083412731967e-02,7.0441717685312344e-03,3.8101192399999170e-14,3.4157270584159780e-10,4.3725160313128580e-08,1.1446000285247633e-06,
 1.2785913171525713e-05,8.2986905188937337e-05,3.6654001715147392e-04,1.2064254866148046e-03,3.1288376407483075e-03,6.6232175485433642e-03,1.1692111893011692e-02,1.7395545604028086e-02,2.1791972812158111e-02,2.2561513958364404e-02,
 1.8158462400900938e-02,8.8758995101891267e-03,3.5995956938294196e-14,3.2269951768677604e-10,4.1309179283098267e-08,1.0813565335647756e-06,1.2079442950426354e-05,7.8401563768995243e-05,3.4628729030397376e-04,1.1397659004878831e-03,
 2.9559574881780491e-03,6.2572596460347685e-03,1.1046078343169530e-02,1.6434375698980527e-02,2.0587883620853249e-02,2.1314904698573847e-02,1.7155138447805605e-02,8.3854723811058827e-03,2.3422550587436921e-14,2.0998040948090412e-10,
 2.6879861622862642e-08,7.0363813785795299e-07,7.8600872886761305e-06,5.1015857049207698e-05,2.2532896093956843e-04,7.4164508274573255e-04,1.9234400107726189e-03,4.0715956197307952e-03,7.1876774724783992e-03,1.0693839778789252e-02,
 1.3396525238218911e-02,1.3869597477977249e-02,1.1162839727167773e-02,5.4564225471960808e-03,8.5741408455818859e-15,7.6866163613620521e-11,9.8397362235944082e-09,2.5757623943623814e-07,2.8772910627344148e-06,1.8675043183921838e-05,
 8.2484708079603474e-05,2.7148919470392283e-04,7.0410118226994691e-04,1.4904625429030306e-03,2.6311463720224012e-03,3.9146244172316999e-03,4.9039789157501248e-03,5.0771533955609825e-03,4.0863081798072822e-03,1.9973971347834905e-03,
 8.4751572493238367e-16,7.5978787322273929e-12,9.7261420460338823e-10,2.5460266774559339e-08,2.8440743682573998e-07,1.8459450395336907e-06,8.1532468876975753e-06,2.6835500583054513e-05,6.9597273320364352e-05,1.4732559976361097e-04,
 2.6007712784853856e-04,3.8694322971352798e-04,4.8473652587322646e-04,5.0185405373286206e-04,4.0391340679819061e-04,1.9743383169827230e-04};
const double QUAD_SINGULAR_B1[N_SINGULAR_3D] = {2.2152633436600595e-14,2.2152633436600595e-14,2.2152633436600595e-14,2.2152633436600595e-14,2.2152633436600595e-14,2.2152633436600595e-14,2.2152633436600595e-14,2.2152633436600595e-14,2.2152633436600595e-14,2.2152633436600595e-14,
 2.2152633436600595e-14,2.2152633436600595e-14,2.2152633436600595e-14,2.2152633436600595e-14,2.2152633436600595e-14,2.2152633436600595e-14,4.5295301203492587e-10,4.5295301203492587e-10,4.5295301203492587e-10,4.5295301203492587e-10,
 4.5295301203492587e-10,4.5295301203492587e-10,4.5295301203492587e-10,4.5295301203492587e-10,4.5295301203492587e-10,4.5295301203492587e-10,4.5295301203492587e-10,4.5295301203492587e-10,4.5295301203492587e-10,4.5295301203492587e-10,
 4.5295301203492587e-10,4.5295301203492587e-10,9.1962466664210781e-08,9.1962466664210781e-08,9.1962466664210781e-08,9.1962466664210781e-08,9.1962466664210781e-08,9.1962466664210781e-08,9.1962466664210781e-08,9.1962466664210781e-08,
 9.1962466664210781e-08,9.1962466664210781e-08,9.1962466664210781e-08,9.1962466664210781e-08,9.1962466664210781e-08,9.1962466664210781e-08,9.1962466664210781e-08,9.1962466664210781e-08,3.3458909236091931e-06,3.3458909236091931e-06,
 3.3458909236091931e-06,3.3458909236091931e-06,3.3458909236091931e-06,3.3458909236091931e-06,3.3458909236091931e-06,3.3458909236091931e-06,3.3458909236091931e-06,3.3458909236091931e-06,3.3458909236091931e-06,3.3458909236091931e-06,
 3.3458909236091931e-06,3.3458909236091931e-06,3.3458909236091931e-06,3.3458909236091931e-06,4.8645676866854997e-05,4.8645676866854997e-05,4.8645676866854997e-05,4.8645676866854997e-05,4.8645676866854997e-05,4.8645676866854997e-05,
 4.8645676866854997e-05,4.8645676866854997e-05,4.8645676866854997e-05,4.8645676866854997e-05,4.8645676866854997e-05,4.8645676866854997e-05,4.8645676866854997e-05,4.8645676866854997e-05,4.8645676866854997e-05,4.8645676866854997e-05,
 3.9603638009126749e-04,3.9603638009126749e-04,3.9603638009126749e-04,3.9603638009126749e-04,3.9603638009126749e-04,3.9603638009126749e-04,3.9603638009126749e-04,3.9603638009126749e-04,3.9603638009126749e-04,3.9603638009126749e-04,
 3.9603638009126749e-04,3.9603638009126749e-04,3.9603638009126749e-04,3.9603638009126749e-04,3.9603638009126749e-04,3.9603638009126749e-04,2.1478556403678852e-03,2.1478556403678852e-03,2.1478556403678852e-03,2.1478556403678852e-03,
 2.1478556403678852e-03,2.1478556403678852e-03,2.1478556403678852e-03,2.1478556403678852e-03,2.1478556403678852e-03,2.1478556403678852e-03,2.1478556403678852e-03,2.1478556403678852e-03,2.1478556403678852e-03,2.1478556403678852e-03,
 2.1478556403678852e-03,2.1478556403678852e-03,8.5837187917145782e-03,8.5837187917145782e-03,8.5837187917145782e-03,8.5837187917145782e-03,8.5837187917145782e-03,8.5837187917145782e-03,8.5837187917145782e-03,8.5837187917145782e-03,
 8.5837187917145782e-03,8.5837187917145782e-03,8.5837187917145782e-03,8.5837187917145782e-03,8.5837187917145782e-03,8.5837187917145782e-03,8.5837187917145782e-03,8.5837187917145782e-03,2.6936087273817601e-02,2.6936087273817601e-02,
 2.6936087273817601e-02,2.6936087273817601e-02,2.6936087273817601e-02,2.6936087273817601e-02,2.6936087273817601e-02,2.6936087273817601e-02,2.6936087273817601e-02,2.6936087273817601e-02,2.6936087273817601e-02,2.6936087273817601e-02,
 2.6936087273817601e-02,2.6936087273817601e-02,2.6936087273817601e-02,2.6936087273817601e-02,6.9237637071716762e-02,6.9237637071716762e-02,6.9237637071716762e-02,6.9237637071716762e-02,6.9237637071716762e-02,6.9237637071716762e-02,
 6.9237637071716762e-02,6.9237637071716762e-02,6.9237637071716762e-02,6.9237637071716762e-02,6.9237637071716762e-02,6.9237637071716762e-02,6.9237637071716762e-02,6.9237637071716762e-02,6.9237637071716762e-02,6.9237637071716762e-02,
 1.5010499870765392e-01,1.5010499870765392e-01,1.5010499870765392e-01,1.5010499870765392e-01,1.5010499870765392e-01,1.5010499870765392e-01,1.5010499870765392e-01,1.5010499870765392e-01,1.5010499870765392e-01,1.5010499870765392e-01,
 1.5010499870765392e-01,1.5010499870765392e-01,1.5010499870765392e-01,1.5010499870765392e-01,1.5010499870765392e-01,1.5010499870765392e-01,2.8021528122253964e-01,2.8021528122253964e-01,2.8021528122253964e-01,2.8021528122253964e-01,
 2.8021528122253964e-01,2.8021528122253964e-01,2.8021528122253964e-01,2.8021528122253964e-01,2.8021528122253964e-01,2.8021528122253964e-01,2.8021528122253964e-01,2.8021528122253964e-01,2.8021528122253964e-01,2.8021528122253964e-01,
 2.8021528122253964e-01,2.8021528122253964e-01,4.5717569525535973e-01,4.5717569525535973e-01,4.5717569525535973e-01,4.5717569525535973e-01,4.5717569525535973e-01,4.5717569525535973e-01,4.5717569525535973e-01,4.5717569525535973e-01,
 4.5717569525535973e-01,4.5717569525535973e-01,4.5717569525535973e-01,4.5717569525535973e-01,4.5717569525535973e-01,4.5717569525535973e-01,4.5717569525535973e-01,4.5717569525535973e-01,6.5883218333522442e-01,6.5883218333522442e-01,
 6.5883218333522442e-01,6.5883218333522442e-01,6.5883218333522442e-01,6.5883218333522442e-01,6.5883218333522442e-01,6.5883218333522442e-01,6.5883218333522442e-01,6.5883218333522442e-01,6.5883218333522442e-01,6.5883218333522442e-01,
 6.5883218333522442e-01,6.5883218333522442e-01,6.5883218333522442e-01,6.5883218333522442e-01,8.4482789494683763e-01,8.4482789494683763e-01,8.4482789494683763e-01,8.4482789494683763e-01,8.4482789494683763e-01,8.4482789494683763e-01,
 8.4482789494683763e-01,8.4482789494683763e-01,8.4482789494683763e-01,8.4482789494683763e-01,8.4482789494683763e-01,8.4482789494683763e-01,8.4482789494683763e-01,8.4482789494683763e-01,8.4482789494683763e-01,8.4482789494683763e-01,
 9.6862111570072751e-01,9.6862111570072751e-01,9.6862111570072751e-01,9.6862111570072751e-01,9.6862111570072751e-01,9.6862111570072751e-01,9.6862111570072751e-01,9.6862111570072751e-01,9.6862111570072751e-01,9.6862111570072751e-01,
 9.6862111570072751e-01,9.6862111570072751e-01,9.6862111570072751e-01,9.6862111570072751e-01,9.6862111570072751e-01,9.6862111570072751e-01};
const double QUAD_SINGULAR_B2[N_SINGULAR_3D] = {2.2152633436600102e-14,4.5295301203491579e-10,9.1962466664208743e-08,3.3458909236091190e-06,4.8645676866853920e-05,3.9603638009125871e-04,2.1478556403678375e-03,8.5837187917143874e-03,2.6936087273817005e-02,6.9237637071715222e-02,
 1.5010499870765059e-01,2.8021528122253342e-01,4.5717569525534957e-01,6.5883218333520976e-01,8.4482789494681887e-01,9.6862111570070597e-01,2.2152633426566492e-14,4.5295301182975944e-10,9.1962466622556110e-08,3.3458909220936618e-06,
 4.8645676844820790e-05,3.9603637991188163e-04,2.1478556393950076e-03,8.5837187878265563e-03,2.6936087261616819e-02,6.9237637040355363e-02,1.5010499863966342e-01,2.8021528109561528e-01,4.5717569504828059e-01,6.5883218303680435e-01,
 8.4482789456417029e-01,9.6862111526198769e-01,2.2152631399389780e-14,4.5295297038024962e-10,9.1962458207115511e-08,3.3458906159128105e-06,4.8645672393278560e-05,3.9603634367078508e-04,2.1478554428457823e-03,8.5837180023346244e-03,
 2.6936084796708573e-02,6.9237630704452879e-02,1.5010498490362797e-01,2.8021525545325121e-01,4.5717565321235509e-01,6.5883212274739178e-01,8.4482781725438050e-01,9.6862102662394045e-01,2.2152559316305445e-14,4.5295149650355406e-10,
 9.1962158967828254e-08,3.3458797286231204e-06,4.8645514103726291e-05,3.9603505499673789e-04,2.1478484538771927e-03,8.5836900715277817e-03,2.6935997148607674e-02,6.9237405410135303e-02,1.5010449647270116e-01,2.8021434365277353e-01,
 4.5717416559535046e-01,6.5882997895460194e-01,8.4482506824485193e-01,9.6861787480012806e-01,2.2151555806752687e-14,4.5293097782906653e-10,9.1957993087773547e-08,3.3457281604804914e-06,4.8643310464977161e-05,3.9601711463349402e-04,
 2.1477511564764471e-03,8.5833012309039208e-03,2.6934776949620022e-02,6.9234268959996736e-02,1.5009769674839069e-01,2.8020164996051611e-01,4.5715345563421694e-01,6.5880013399772441e-01,8.4478679772205190e-01,9.6857399647092668e-01,
 2.2143860187844875e-14,4.5277362616368813e-10,9.1926046181808826e-08,3.3445658290796268e-06,4.8626411409081558e-05,3.9587953527691168e-04,2.1470050113951153e-03,8.5803193267965858e-03,2.6925419603319858e-02,6.9210216448564815e-02,
 1.5004555166733216e-01,2.8010430577691803e-01,4.5699463704794513e-01,6.5857126182224879e-01,8.4449331236552283e-01,9.6823750650038543e-01,2.2105052777924789e-14,4.5198013435320505e-10,9.1764944561483910e-08,3.3387044329168635e-06,
 4.8541192975417006e-05,3.9518575111849758e-04,2.1432423565160251e-03,8.5652822028924620e-03,2.6878232446837090e-02,6.9088924622406525e-02,1.4978259483953227e-01,2.7961341925024852e-01,4.5619374785966638e-01,6.5741710691419197e-01,
 8.4301332658753592e-01,9.6654065737399020e-01,2.1962481460684880e-14,4.4906499075375794e-10,9.1173086710972774e-08,3.3171707368131816e-06,4.8228116056197299e-05,3.9263691517327546e-04,2.1294190515457690e-03,8.5100385634193434e-03,
 2.6704875475310069e-02,6.8643320665290358e-02,1.4881653960951674e-01,2.7780999204738416e-01,4.5325142764888110e-01,6.5317695314254354e-01,8.3757612986921781e-01,9.6030674442783559e-01,2.1555928169007431e-14,4.4075223017181457e-10,
 8.9485357636228054e-08,3.2557657136821820e-06,4.7335352669275463e-05,3.8536870959352232e-04,2.0900008133873747e-03,8.3525069932070470e-03,2.6210534476194883e-02,6.7372646036920086e-02,1.4606175736222829e-01,2.7266737795207197e-01,
 4.4486117082849314e-01,6.4108582214610699e-01,8.2207153703719404e-01,9.4253025279295011e-01,2.0618837442534467e-14,4.2159161577711075e-10,8.5595202773094314e-08,3.1142293421587887e-06,4.5277565146839686e-05,3.6861575693931188e-04,
 1.9991431910576537e-03,7.9894023852881690e-03,2.5071096239020933e-02,6.4443786684441992e-02,1.3971208328448287e-01,2.6081383727930441e-01,4.2552193038925940e-01,6.1321619973429342e-01,7.8633400776844609e-01,9.0155607843183927e-01,
 1.8827412423228532e-14,3.8496250074879538e-10,7.8158440724426753e-08,2.8436559708448842e-06,4.1343717603622778e-05,3.3658933976948386e-04,1.8254517722462366e-03,7.2952596935773970e-03,2.2892845928391956e-02,5.8844721648545706e-02,
 1.2757348807062913e-01,2.3815356679676544e-01,3.8855133810988318e-01,5.5993817930712975e-01,7.1801500486765257e-01,8.2322624438026348e-01,1.5945127028343726e-14,3.2602865638696275e-10,6.6193178205980532e-08,2.4083211575101005e-06,
 3.5014414843348435e-05,2.8506093446963639e-04,1.5459936680767804e-03,6.1784296165590799e-03,1.9388184003349934e-02,4.9836193128481518e-02,1.0804328428187975e-01,2.0169467739191269e-01,3.2906807924126907e-01,4.7421733780348474e-01,
 6.0809420877966336e-01,6.9719867736655805e-01,1.2024987843485588e-14,2.4587390383984933e-10,4.9919462029602372e-08,1.8162309143595625e-06,2.6406055724082996e-05,2.1497817267662636e-04,1.1659082446745515e-03,4.6594511852359691e-03,
 1.4621562846950993e-02,3.7583872205616382e-02,8.1480641562177367e-02,1.5210766520844893e-01,2.4816607892313819e-01,3.5763012186233656e-01,4.5859311470339514e-01,5.2579108369122518e-01,7.5577655829401285e-15,1.5453299016768948e-10,
 3.1374633966936000e-08,1.1415103012062379e-06,1.6596339366845100e-05,1.3511486711555892e-04,7.3277921933543482e-04,2.9284885990336681e-03,9.1897260847001987e-03,2.3621653470785733e-02,5.1210994679559252e-02,9.5600435690799929e-02,
 1.5597363378247187e-01,2.2477233753696566e-01,2.8822808837651098e-01,3.3046235121901618e-01,3.4374707628283847e-15,7.0285672367629831e-11,1.4270009538166857e-08,5.1918893789470813e-07,7.5484520811658143e-06,6.1453798776396300e-05,
 3.3328728106619282e-04,1.3319537140947385e-03,4.1797293641739749e-03,1.0743749893325162e-02,2.3292108628468877e-02,4.3481595055365356e-02,7.0940915011917224e-02,1.0223237676489777e-01,1.3109372286653270e-01,1.5030297752222463e-01,
 6.9512492153128526e-16,1.4213160157650919e-11,2.8856796013319736e-09,1.0499032416991885e-07,1.5264470660648393e-06,1.2427179749186586e-05,6.7397313630643691e-05,2.6934751882270281e-04,8.4522436604022872e-04,2.1725998028284199e-03,
 4.7101273871899196e-03,8.7928428883701747e-03,1.4345663245857393e-02,2.0673418853513089e-02,2.6509756768334752e-02,3.0394249919405363e-02};



EXPORT double
triangle_integral_singular(double target[3], triangle6 vertices, integration_cb_3d function, void *args) {
	
	double sum_ = 0.0;
	
	for (int k=0; k < N_SINGULAR_3D; k++) {
		double b1_ = QUAD_SINGULAR_B1[k];
		double b2_ = QUAD_SINGULAR_B2[k];
		double w = QUAD_SINGULAR_WEIGHTS[k];
		
		double pos[3], jac;
		position_and_jacobian_3d(b1_, b2_, vertices, pos, &jac);
		
        sum_ += 0.5*w*jac*function(target[0], target[1], target[2], pos[0], pos[1], pos[2], args);
	}
	      
    return sum_;
}

EXPORT inline double potential_3d_point(double x0, double y0, double z0, double x, double y, double z, void *_) {
	double r = norm_3d(x-x0, y-y0, z-z0);
    return 1/(4*r);
}

//////////////////////////////// PARTICLE TRACING


const double EM = -0.1758820022723908; // e/m units ns and mm

const double A[]  = {0.0, 2./9., 1./3., 3./4., 1., 5./6.};	// https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta%E2%80%93Fehlberg_method
const double B6[] = {65./432., -5./16., 13./16., 4./27., 5./144.};
const double B5[] = {-17./12., 27./4., -27./5., 16./15.};
const double B4[] = {69./128., -243./128., 135./64.};
const double B3[] = {1./12., 1./4.};
const double B2[] = {2./9.};
const double CH[] = {47./450., 0., 12./25., 32./225., 1./30., 6./25.};
const double CT[] = {-1./150., 0., 3./100., -16./75., -1./20., 6./25.};

typedef void (*field_fun)(double pos[6], double field[3], void* args);

void
produce_new_y(double y[6], double ys[6][6], double ks[6][6], size_t index) {
	
	const double* coefficients[] = {NULL, B2, B3, B4, B5, B6};
	
	for(int i = 0; i < 6; i++) {
		
		ys[index][i] = y[i];
		
		for(int j = 0; j < index; j++) 
			ys[index][i] += coefficients[index][j]*ks[j][i];
	}
}

void
produce_new_k(double ys[6][6], double ks[6][6], size_t index, double h, field_fun ff, void *args) {
	
	double field[3] = { 0. };
	ff(ys[index], field, args);
	
	ks[index][0] = h*ys[index][3];
	ks[index][1] = h*ys[index][4];
	ks[index][2] = h*ys[index][5];
	ks[index][3] = h*EM*field[0];
	ks[index][4] = h*EM*field[1];
	ks[index][5] = h*EM*field[2];
}


EXPORT size_t
trace_particle(double *times_array, double *pos_array, field_fun field, double bounds[3][2], double atol, void *args) {
	
	double (*positions)[6] = (double (*)[6]) pos_array;
	
	double y[6];
	for(int i = 0; i < 6; i++) y[i] = positions[0][i];

    double V = norm_3d(y[3], y[4], y[5]);
    double hmax = TRACING_STEP_MAX/V;
    double h = hmax;
	
    int N = 1;
		
    double xmin = bounds[0][0], xmax = bounds[0][1];
	double ymin = bounds[1][0], ymax = bounds[1][1];
	double zmin = bounds[2][0], zmax = bounds[2][1];

	 
    while( (xmin <= y[0]) && (y[0] <= xmax) &&
		   (ymin <= y[1]) && (y[1] <= ymax) &&
		   (zmin <= y[2]) && (y[2] <= zmax) ) {
		
		double k[6][6] = { {0.} };
		double ys[6][6] = { {0.} };
		
		for(int index = 0; index < 6; index++) {
			produce_new_y(y, ys, k, index);
			produce_new_k(ys, k, index, h, field, args);
		}
		
		double TE = 0.0; // Error 
		
		for(int i = 0; i < 6; i++) {
			double err = 0.0;
			for(int j = 0; j < 6; j++) err += CT[j]*k[j][i];
			if(fabs(err) > TE) TE = fabs(err);
		}
			
		if(TE <= atol) {
			for(int i = 0; i < 6; i++) {
				y[i] += CH[0]*k[0][i] + CH[1]*k[1][i] + CH[2]*k[2][i] + CH[3]*k[3][i] + CH[4]*k[4][i] + CH[5]*k[5][i];
				positions[N][i] = y[i];
				times_array[N] = times_array[N-1] + h;
			}
				
			N += 1;
			if(N==TRACING_BLOCK_SIZE) return N;
		}
		
		h = fmin(0.9 * h * pow(atol / TE, 0.2), hmax);
	}
		
	return N;
}



//////////////////////////////// RADIAL RING POTENTIAL (DERIVATIVES)


EXPORT double dr1_potential_radial_ring(double r_0, double z_0, double r, double z, void *_) {
	
	if (fabs(r_0) < MIN_DISTANCE_AXIS) return 0.0; // Prevent stepping into singularity
	
    double s = norm_2d(z-z_0, r+r_0);
    double s1 = (r_0 + r) / s;
    double t = 4.0 * r * r_0 / pow(s, 2);
    double A = ellipe(t);
    double B = ellipk(t);
    double ellipe_term = -(2.0 * r * r_0 * s1 - r * s) / (2.0 * r_0 * pow(s, 2) - 8.0 * pow(r_0, 2) * r);
    double ellipk_term = -r / (2.0 * r_0 * s);
    return A * ellipe_term + B * ellipk_term;
}


EXPORT double potential_radial_ring(double r_0, double z_0, double r, double z, void *_) {
    double rz2 = pow(r + r_0, 2) + pow(z - z_0, 2);
    double t = 4.0 * r * r_0 / rz2;
    return ellipk(t) * r / sqrt(rz2);
}

EXPORT double dz1_potential_radial_ring(double r_0, double z_0, double r, double z, void *_) {
    double rz2 = pow(r + r_0, 2) + pow(z - z_0, 2);
    double t = 4.0 * r * r_0 / rz2;
    double numerator = r * (z - z_0) * ellipe(t);
    double denominator = ((pow(z - z_0, 2) + pow(r - r_0, 2)) * sqrt(rz2));
    return numerator / denominator;
}


EXPORT void
axial_derivatives_radial_ring(double *derivs_p, vertices_2d lines, charges_2d charges, size_t N_lines, double *z, size_t N_z) {

	double (*derivs)[9] = (double (*)[9]) derivs_p;	
		
	for(int i = 0; i < N_z; i++) 
	for(int j = 0; j < N_lines; j++)
	for(int k = 0; k < N_QUAD_2D; k++) {
		double z0 = z[i];

		double *v1 = &lines[j][0][0];
		double *v2 = &lines[j][2][0];
		double *v3 = &lines[j][3][0];
		double *v4 = &lines[j][1][0];
			
		double pos[2], jac;
		position_and_jacobian_radial(GAUSS_QUAD_POINTS[k], v1, v2, v3, v4, pos, &jac);
		double r = pos[0], z = pos[1];
		
		double weight = GAUSS_QUAD_WEIGHTS[k] * jac;
			
		double R = norm_2d(z0-z, r);
		
		double D[9] = {0.}; // Derivatives of the currently considered line element.
		D[0] = 1/R;
		D[1] = -(z0-z)/pow(R, 3);
			
		for(int n = 1; n+1 < DERIV_2D_MAX; n++)
			D[n+1] = -1./pow(R,2) *( (2*n + 1)*(z0-z)*D[n] + pow(n,2)*D[n-1]);
		
		for(int l = 0; l < 9; l++) derivs[i][l] += weight * M_PI*r/2 * charges[j][k]*D[l];
	}
}

//////////////////////////////// RADIAL SYMMETRY POTENTIAL EVALUATION



// John A. Crow. Quadrature of Integrands with a Logarithmic Singularity. 1993.
// Computed higher order points and weights with own Python code..
#define N_LOG_QUAD_2D 12
const double GAUSS_LOG_QUAD_POINTS[N_LOG_QUAD_2D] =
					{0.000245284264977222214486999757349594712755863,
					0.003593698020213691584953180874184458866517133,
					0.01712292595159614370417434799786314278267083,
					0.05020561232318819384573670241984682206686949,
					0.1115235855573625644218104518656856812018872,
					0.2060030029051239758752495945505766309866304,
					0.3324626975136065400973675503604997045074356,
					0.4826067009659319425485030383099190543511725,
					0.6416794701239928589863342367708391692838668,
					0.7907090871833554068663998987642233419999952,
					0.9098838287655625921196627463680156613773641,
					0.9823479377157619510221418912858930542857947};

const double GAUSS_LOG_QUAD_WEIGHTS[N_LOG_QUAD_2D] =
					{0.0009331998830671428063097434941623766739840873,
					0.006977495915143715985530451759041482867494198,
					0.02169468902199853397715717421909584842021132,
					0.04597069439559112469266362311262695693833166,
					0.07752703869583178458842135310107317470803586,
					0.1112525181837396068263131383589812009329696,
					0.1402731060085833332292272698216837072064324,
					0.1575171300868296275541516485738687199310457,
					0.1574083422236489759715520802610080785790687,
					0.1372838327177858585860313716723887135089706,
					0.09819669547418950067876642091789781881144955,
					0.04496525739359079510387572470817192142199618};



EXPORT double
potential_radial(double point[3], vertices_2d vertices, charges_2d charges, size_t N_vertices) {

	double sum_ = 0.0;
	
	for(int i = 0; i < N_vertices; i++) {
		double *v1 = &vertices[i][0][0];
		double *v2 = &vertices[i][2][0]; // Strange ordering following from GMSH line4 element
		double *v3 = &vertices[i][3][0]; // Strange ordering following from GMSH line4 element
		double *v4 = &vertices[i][1][0];
		
		for(int j = 0; j < N_QUAD_2D; j++) {
			double pos[2], jac;
			position_and_jacobian_radial(GAUSS_QUAD_POINTS[j], v1, v2, v3, v4, pos, &jac);
			sum_ += jac*GAUSS_QUAD_WEIGHTS[j] * charges[i][j] * potential_radial_ring(point[0], point[1], pos[0], pos[1], NULL);
		}
	}

	return sum_;
}

EXPORT double
potential_radial_derivs(double point[2], double *z_inter, double *coeff_p, size_t N_z) {
	
	double (*coeff)[DERIV_2D_MAX][6] = (double (*)[DERIV_2D_MAX][6]) coeff_p;
	
	double r = point[0], z = point[1];
	double z0 = z_inter[0], zlast = z_inter[N_z-1];
	
	if(!(z0 < z && z < zlast)) {
		return 0.0;
	}
	
	double dz = z_inter[1] - z_inter[0];
	int index = (int) ( (z-z0)/dz );
	double diffz = z - z_inter[index];
		
	double (*C)[6] = &coeff[index][0];
		
	double derivs[DERIV_2D_MAX];

	for(int i = 0; i < DERIV_2D_MAX; i++)
		derivs[i] = C[i][0]*pow(diffz, 5) + C[i][1]*pow(diffz, 4) + C[i][2]*pow(diffz, 3)
			      +	C[i][3]*pow(diffz, 2) + C[i][4]*diffz		  + C[i][5];
		
	return derivs[0] - pow(r,2)*derivs[2] + pow(r,4)/64.*derivs[4] - pow(r,6)/2304.*derivs[6] + pow(r,8)/147456.*derivs[8];
}


//////////////////////////////// RADIAL SYMMETRY FIELD EVALUATION


double
field_dot_normal_radial(double r0, double z0, double r, double z, void* args_p) {

	struct {double *normal; double K;} *args = args_p;
	
	// This factor is hard to derive. It takes into account that the field
	// calculated at the edge of the dielectric is basically the average of the
	// field at either side of the surface of the dielecric (the field makes a jump).
	double K = args->K;
	double factor = (2*K - 2) / (M_PI*(1 + K));
	
	double Er = -dr1_potential_radial_ring(r0, z0, r, z, NULL);
	double Ez = -dz1_potential_radial_ring(r0, z0, r, z, NULL);
	
	return factor*(args->normal[0]*Er + args->normal[1]*Ez);

}

EXPORT double
charge_radial(double *vertices_p, double *charges) {

	double (*vertices)[3] = (double (*)[3]) vertices_p;
		
	double *v1 = &vertices[0][0];
	double *v2 = &vertices[2][0]; // Strange ordering following from GMSH line4 element
	double *v3 = &vertices[3][0];
	double *v4 = &vertices[1][0];
		
	double sum_ = 0.0;
	
	for(int k = 0; k < N_QUAD_2D; k++) {
				
		double pos[2], jac;
		position_and_jacobian_radial(GAUSS_QUAD_POINTS[k], v1, v2, v3, v4, pos, &jac);
		
		// Surface area is 2pi*r * charge_integral
		// charge_integral is charge integrated over line element
		// charge_integral is weight*dl*charge
		// where dl is the jacobian
		sum_ += 2*M_PI*pos[0]*GAUSS_QUAD_WEIGHTS[k]*jac*charges[k];
	}

	return sum_;
}

EXPORT void
field_radial(double point[3], double result[3], vertices_2d vertices, charges_2d charges, size_t N_vertices) {
		
	double Ex = 0.0, Ey = 0.0;
	
	for(int i = 0; i < N_vertices; i++) 
	for(int k = 0; k < N_QUAD_2D; k++) {
			
		double *v1 = &vertices[i][0][0];
		double *v2 = &vertices[i][2][0]; // Strange ordering following from GMSH line4 element
		double *v3 = &vertices[i][3][0];
		double *v4 = &vertices[i][1][0];
		
		double pos[2], jac;
		position_and_jacobian_radial(GAUSS_QUAD_POINTS[k], v1, v2, v3, v4, pos, &jac);
		
		Ex -= GAUSS_QUAD_WEIGHTS[k] * jac * charges[i][k] * dr1_potential_radial_ring(point[0], point[1], pos[0], pos[1], NULL);
		Ey -= GAUSS_QUAD_WEIGHTS[k] * jac * charges[i][k] * dz1_potential_radial_ring(point[0], point[1], pos[0], pos[1], NULL);
	}
		
	result[0] = Ex;
	result[1] = Ey;
	result[2] = 0.0;
}

struct field_evaluation_args {
	double *vertices;
	double *charges;
	size_t N_vertices;
};

void
field_radial_traceable(double point[3], double result[3], void *args_p) {

	struct field_evaluation_args *args = (struct field_evaluation_args*)args_p;
	field_radial(point, result, (vertices_2d) args->vertices, (charges_2d) args->charges, args->N_vertices);
}

EXPORT size_t
trace_particle_radial(double *times_array, double *pos_array, double bounds[3][2], double atol,
	double *vertices, double *charges, size_t N_vertices) {

	struct field_evaluation_args args = { vertices, charges, N_vertices };
				
	return trace_particle(times_array, pos_array, field_radial_traceable, bounds, atol, (void*) &args);
}

EXPORT void
field_radial_derivs(double point[3], double field[3], double *z_inter, double *coeff_p, size_t N_z) {
	
	double (*coeff)[DERIV_2D_MAX][6] = (double (*)[DERIV_2D_MAX][6]) coeff_p;
	
	double r = point[0], z = point[1];
	double z0 = z_inter[0], zlast = z_inter[N_z-1];
	
	if(!(z0 < z && z < zlast)) {
		field[0] = 0.0, field[1] = 0.0; field[2] = 0.0;
		return;
	}
	
	double dz = z_inter[1] - z_inter[0];
	int index = (int) ( (z-z0)/dz );
	double diffz = z - z_inter[index];
		
	double (*C)[6] = &coeff[index][0];
		
	double derivs[DERIV_2D_MAX];

	for(int i = 0; i < DERIV_2D_MAX; i++)
		derivs[i] = C[i][0]*pow(diffz, 5) + C[i][1]*pow(diffz, 4) + C[i][2]*pow(diffz, 3)
			      +	C[i][3]*pow(diffz, 2) + C[i][4]*diffz		  + C[i][5];
		
	field[0] = r/2*(derivs[2] - pow(r,2)/8*derivs[4] + pow(r,4)/192*derivs[6] - pow(r,6)/9216*derivs[8]);
	field[1] = -derivs[1] + pow(r,2)/4*derivs[3] - pow(r,4)/64*derivs[5] + pow(r,6)/2304*derivs[7];
	field[2] = 0.0;
}

struct field_derivs_args {
	double *z_interpolation;
	double *axial_coefficients;
	size_t N_z;
};

void
field_radial_derivs_traceable(double point[3], double field[3], void *args_p) {
	struct field_derivs_args *args = (struct field_derivs_args*) args_p;
	field_radial_derivs(point, field, args->z_interpolation, args->axial_coefficients, args->N_z);
}

EXPORT size_t
trace_particle_radial_derivs(double *times_array, double *pos_array, double bounds[3][2], double atol,
	double *z_interpolation, double *axial_coefficients, size_t N_z) {

	struct field_derivs_args args = { z_interpolation, axial_coefficients, N_z };
		
	return trace_particle(times_array, pos_array, field_radial_derivs_traceable, bounds, atol, (void*) &args);
}


//////////////////////////////// 3D POINT POTENTIAL (DERIVATIVES)

EXPORT double dx1_potential_3d_point(double x0, double y0, double z0, double x, double y, double z, void *_) {
	double r = norm_3d(x-x0, y-y0, z-z0);
    return (x-x0)/(4*pow(r, 3));
}

EXPORT double dy1_potential_3d_point(double x0, double y0, double z0, double x, double y, double z, void *_) {
	double r = norm_3d(x-x0, y-y0, z-z0);
    return (y-y0)/(4*pow(r, 3));
}

EXPORT double dz1_potential_3d_point(double x0, double y0, double z0, double x, double y, double z, void *_) {
	double r = norm_3d(x-x0, y-y0, z-z0);
    return (z-z0)/(4*pow(r, 3));
}

EXPORT void
axial_coefficients_3d(double *restrict vertices_p, double *restrict charges, size_t N_v,
	double *restrict zs, double *restrict output_coeffs_p, size_t N_z,
	double *restrict thetas, double *restrict theta_coeffs_p, size_t N_t) {
	
	double (*vertices)[3][3] = (double (*)[3][3]) vertices_p;
	double (*theta_coeffs)[NU_MAX][M_MAX][4] = (double (*)[NU_MAX][M_MAX][4]) theta_coeffs_p;
	double (*output_coeffs)[2][NU_MAX][M_MAX] = (double (*)[2][NU_MAX][M_MAX]) output_coeffs_p;

	double theta0 = thetas[0];
	double dtheta = thetas[1] - thetas[0];
	
	for(int h = 0; h < N_v; h++) {

		double v1x = vertices[h][0][0], v1y = vertices[h][0][1], v1z = vertices[h][0][2];
		double v2x = vertices[h][1][0], v2y = vertices[h][1][1], v2z = vertices[h][1][2];
		double v3x = vertices[h][2][0], v3y = vertices[h][2][1], v3z = vertices[h][2][2];
			
		double area = 0.5*sqrt(pow((v2y-v1y)*(v3z-v1z)-(v2z-v1z)*(v3y-v1y), 2) + pow((v2z-v1z)*(v3x-v1x)-(v2x-v1x)*(v3z-v1z), 2) + pow((v2x-v1x)*(v3y-v1y)-(v2y-v1y)*(v3x-v1x), 2));
		
        for (int i=0; i < N_z; i++) 
		UNROLL
		for (int k=0; k < N_TRIANGLE_QUAD; k++) {
			double b1_ = QUAD_B1[k];
			double b2_ = QUAD_B2[k];
			double w = QUAD_WEIGHTS[k];

			double x = v1x + b1_*(v2x-v1x) + b2_*(v3x-v1x);
			double y = v1y + b1_*(v2y-v1y) + b2_*(v3y-v1y);
			double z = v1z + b1_*(v2z-v1z) + b2_*(v3z-v1z);

			double r = norm_3d(x, y, z-zs[i]);
			double theta = atan2((z-zs[i]), norm_2d(x, y));
			double mu = atan2(y, x);

			int index = (int) ((theta-theta0)/dtheta);

			double t = theta-thetas[index];
			double (*C)[M_MAX][4] = &theta_coeffs[index][0];
				
			UNROLL
			for (int nu=0; nu < NU_MAX; nu++)
			UNROLL
			for (int m=0; m < M_MAX; m++) {
				double base = pow(t, 3)*C[nu][m][0] + pow(t, 2)*C[nu][m][1] + t*C[nu][m][2] + C[nu][m][3];
				double r_dependence = pow(r, -2*nu - m - 1);
					
				output_coeffs[i][0][nu][m] += charges[h]*area*w*base*cos(m*mu)*r_dependence;
				output_coeffs[i][1][nu][m] += charges[h]*area*w*base*sin(m*mu)*r_dependence;
			}
		}
	}
}


//////////////////////////////// 3D POINT POTENTIAL EVALUATION

EXPORT double
potential_3d(double point[3], vertices_3d vertices, double *charges, size_t N_vertices) {
	
	double sum_ = 0.0;
		
	for(int i = 0; i < N_vertices; i++) {
		sum_ += charges[i] * triangle_integral(point, &vertices[i][0], potential_3d_point, NULL);
	}
	
	return sum_;
}

EXPORT double
potential_3d_derivs(double point[3], double *zs, double *coeffs_p, size_t N_z) {

	double (*coeffs)[2][NU_MAX][M_MAX][4] = (double (*)[2][NU_MAX][M_MAX][4]) coeffs_p;
	
	double xp = point[0], yp = point[1], zp = point[2];

	if (!(zs[0] < zp && zp < zs[N_z-1])) return 0.0;

	double dz = zs[1] - zs[0];
	int index = (int) ((zp-zs[0])/dz);
	
	double z_ = zp - zs[index];

	double A[NU_MAX][M_MAX], B[NU_MAX][M_MAX];
	double (*C)[NU_MAX][M_MAX][4] = &coeffs[index][0];
		
	for (int nu=0; nu < NU_MAX; nu++)
	for (int m=0; m < M_MAX; m++) {
		A[nu][m] = pow(z_, 3)*C[0][nu][m][0] + pow(z_, 2)*C[0][nu][m][1] + z_*C[0][nu][m][2] + C[0][nu][m][3];
		B[nu][m] = pow(z_, 3)*C[1][nu][m][0] + pow(z_, 2)*C[1][nu][m][1] + z_*C[1][nu][m][2] + C[1][nu][m][3];
	}

	double r = norm_2d(xp, yp);
	double phi = atan2(yp, xp);
	
	double sum_ = 0.0;
	
	for (int nu=0; nu < NU_MAX; nu++)
	for (int m=0; m < M_MAX; m++)
		sum_ += (A[nu][m]*cos(m*phi) + B[nu][m]*sin(m*phi))*pow(r, (m+2*nu));
	
	return sum_;
}

//////////////////////////////// 3D POINT FIELD EVALUATION

double
field_dot_normal_3d(double x0, double y0, double z0, double x, double y, double z, void* normal_p) {
	
	double Ex = -dx1_potential_3d_point(x0, y0, z0, x, y, z, NULL);
	double Ey = -dy1_potential_3d_point(x0, y0, z0, x, y, z, NULL);
	double Ez = -dz1_potential_3d_point(x0, y0, z0, x, y, z, NULL);
	
	double *normal = (double *)normal_p;
	
    return normal[0]*Ex + normal[1]*Ey + normal[2]*Ez;
}


EXPORT void
field_3d(double point[3], double result[3], vertices_3d vertices, double *charges, size_t N_vertices) {
		
	double Ex = 0.0, Ey = 0.0, Ez = 0.0;
	
	for(int i = 0; i < N_vertices; i++) {
		Ex -= charges[i]*triangle_integral(point, &vertices[i][0], dx1_potential_3d_point, NULL);
		Ey -= charges[i]*triangle_integral(point, &vertices[i][0], dy1_potential_3d_point, NULL);
		Ez -= charges[i]*triangle_integral(point, &vertices[i][0], dz1_potential_3d_point, NULL);
	} 

	result[0] = Ex;
	result[1] = Ey;
	result[2] = Ez;
}

void
field_3d_traceable(double point[3], double result[3], void *args_p) {

	struct field_evaluation_args *args = (struct field_evaluation_args*)args_p;
	field_3d(point, result, (vertices_3d) args->vertices, args->charges, args->N_vertices);
}

EXPORT size_t
trace_particle_3d(double *times_array, double *pos_array, double bounds[3][2], double atol,
	double *vertices, double *charges, size_t N_vertices) {

	struct field_evaluation_args args = { vertices, charges, N_vertices };
				
	return trace_particle(times_array, pos_array, field_3d_traceable, bounds, atol, (void*) &args);
}

EXPORT void
field_3d_derivs(double point[3], double field[3], double *restrict zs, double *restrict coeffs_p, size_t N_z) {
	
	double (*coeffs)[2][NU_MAX][M_MAX][4] = (double (*)[2][NU_MAX][M_MAX][4]) coeffs_p;

	double xp = point[0], yp = point[1], zp = point[2];

	field[0] = 0.0, field[1] = 0.0, field[2] = 0.0;
	
	if (!(zs[0] < zp && zp < zs[N_z-1])) return;
		
	double dz = zs[1] - zs[0];
	int index = (int) ((zp-zs[0])/dz);
	
	double z_ = zp - zs[index];

	double A[NU_MAX][M_MAX], B[NU_MAX][M_MAX];
	double Adiff[NU_MAX][M_MAX], Bdiff[NU_MAX][M_MAX];
	
	double (*C)[NU_MAX][M_MAX][4] = &coeffs[index][0];
		
	UNROLL
	for (int nu=0; nu < NU_MAX; nu++)
	UNROLL
	for (int m=0; m < M_MAX; m++) {
		A[nu][m] = pow(z_, 3)*C[0][nu][m][0] + pow(z_, 2)*C[0][nu][m][1] + z_*C[0][nu][m][2] + C[0][nu][m][3];
		B[nu][m] = pow(z_, 3)*C[1][nu][m][0] + pow(z_, 2)*C[1][nu][m][1] + z_*C[1][nu][m][2] + C[1][nu][m][3];
		
		Adiff[nu][m] = 3*pow(z_, 2)*C[0][nu][m][0] + 2*z_*C[0][nu][m][1]+ C[0][nu][m][2];
		Bdiff[nu][m] = 3*pow(z_, 2)*C[1][nu][m][0] + 2*z_*C[1][nu][m][1]+ C[1][nu][m][2];
	}
		
	double r = norm_2d(xp, yp);
	double phi = atan2(yp, xp);
	
	if(r < MIN_DISTANCE_AXIS) {
		field[0] = -A[0][1];
		field[1] = -B[0][1];
		field[2] = -Adiff[0][0];
		return;
	}
	
	
	UNROLL
	for (int nu=0; nu < NU_MAX; nu++)
	UNROLL
	for (int m=0; m < M_MAX; m++) {
		int exp = 2*nu + m;

		double diff_r = (A[nu][m]*cos(m*phi) + B[nu][m]*sin(m*phi)) * exp*pow(r, exp-1);
		double diff_theta = m*(-A[nu][m]*sin(m*phi) + B[nu][m]*cos(m*phi)) * pow(r, exp);
		
		field[0] -= diff_r * xp/r + diff_theta * -yp/pow(r,2);
		field[1] -= diff_r * yp/r + diff_theta * xp/pow(r,2);
		field[2] -= (Adiff[nu][m]*cos(m*phi) + Bdiff[nu][m]*sin(m*phi)) * pow(r, exp);
	}
}

void
field_3d_derivs_traceable(double point[3], double field[3], void *args_p) {
	struct field_derivs_args *args = (struct field_derivs_args*) args_p;
	field_3d_derivs(point, field, args->z_interpolation, args->axial_coefficients, args->N_z);
}

EXPORT size_t
trace_particle_3d_derivs(double *times_array, double *pos_array, double bounds[3][2], double atol,
	double *z_interpolation, double *axial_coefficients, size_t N_z) {

	struct field_derivs_args args = { z_interpolation, axial_coefficients, N_z };
	
	return trace_particle(times_array, pos_array, field_3d_derivs_traceable, bounds, atol, (void*) &args);
}


//////////////////////////////// SOLVER

enum ExcitationType{
    VOLTAGE_FIXED = 1,
    VOLTAGE_FUN = 2,
    DIELECTRIC = 3,
    FLOATING_CONDUCTOR = 4};


double legendre(int N, double x) {
	switch(N) {
		case 0:
			return 1;
		case 1:
			return x;
		case 2:
			return (3*pow(x,2)-1)/2.;
		case 3:
			return (5*pow(x,3) -3*x)/2.;
		case 4:
			return (35*pow(x,4)-30*pow(x,2)+3)/8.;
		case 5:
			return (63*pow(x,5)-70*pow(x,3)+15*x)/8.;
		case 6:
			return (231*pow(x,6)-315*pow(x,4)+105*pow(x,2)-5)/16.;
		case 7:
			return (429*pow(x,7)-693*pow(x,5)+315*pow(x,3)-35*x)/16.;
		case 8:
			return (6435*pow(x,8) - 12012*pow(x,6) + 6930*pow(x,4) - 1260*pow(x,2) + 35) / 128;
		/*case 9:
			return (12155*pow(x,9) - 25740*pow(x,7) + 18018*pow(x,5) - 4620*pow(x,3) + 315*x) / 128;
		case 10:
			return (46189*pow(x,10) - 109395*pow(x,8) + 90090*pow(x,6) - 30030*pow(x,4) + 3465*pow(x,2) - 63) / 256;
		case 11:
			return (88179*pow(x,11) - 230945*pow(x,9) + 218790*pow(x,7) - 90090*pow(x,5) + 15015*pow(x,3) - 693*x) / 256;
		case 12:
			return (676039*pow(x,12) - 1939938*pow(x,10) + 2078505*pow(x,8) - 1021020*pow(x,6) + 225225*pow(x,4) - 18018*pow(x,2) + 231) / 1024;
		case 13:
			return (1300075*pow(x,13) - 4056234*pow(x,11) + 4849845*pow(x,9) - 2771340*pow(x,7) + 765765*pow(x,5) - 90090*pow(x,3) + 3003*x) / 1024;
		case 14:
			return (5014575*pow(x,14) - 16900975*pow(x,12) + 22309287*pow(x,10) - 14549535*pow(x,8) + 4849845*pow(x,6) - 765765*pow(x,4) + 45045*pow(x,2) - 429) / 2048;
		case 15:
			return (9694845*pow(x,15) - 35102025*pow(x,13) + 50702925*pow(x,11) - 37182145*pow(x,9) + 14549535*pow(x,7) - 2909907*pow(x,5) + 255255*pow(x,3) - 6435*x) / 2048;
		case 16:
			return (300540195*pow(x,16) - 1163381400*pow(x,14) + 1825305300*pow(x,12) - 1487285800*pow(x,10) + 669278610*pow(x,8) - 162954792*pow(x,6) + 19399380*pow(x,4) - 875160*pow(x,2) + 6435) / 32768;*/
	}
	exit(1);
}


// Modified weight taking into account that the charge contribution
// is a sum of Legendre polynomials.
double legendre_log_weight(int k, int l, double legendre_arg) {

	double sum_ = 0.0;

	for(int i = 0; i < N_QUAD_2D; i++)
		sum_ += GAUSS_QUAD_WEIGHTS[k] * GAUSS_LOG_QUAD_WEIGHTS[l] * (2*i + 1)/2. * legendre(i, GAUSS_QUAD_POINTS[k]) * legendre(i, legendre_arg);
	
	return sum_;
}


double log_integral(
	double *v1,
	double *v2,
	double *v3,
	double *v4,
	int row, int k,
	integration_cb_2d callback, void *args) {
	
	double s = GAUSS_QUAD_POINTS[row];
	
	double spos[2], jac;
	position_and_jacobian_radial(s, v1, v2, v3, v4, spos, &jac);
	
	double spos_left1[2];
	position_and_jacobian_radial( -1 + 2*(s+1)/3., v1, v2, v3, v4, spos_left1, &jac);
	
	double spos_left2[2];
	position_and_jacobian_radial( -1 + (s+1)/3., v1, v2, v3, v4, spos_left2, &jac);
	
	double spos_right1[2];
	position_and_jacobian_radial( s + (1-s)/3, v1, v2, v3, v4, spos_right1, &jac);
	
	double spos_right2[2];
	position_and_jacobian_radial( s + 2*(1-s)/3, v1, v2, v3, v4, spos_right2, &jac);

	double integration_sum = 0.0;
	
	// Logarithmic integration using improved quadrature weights
	// split the integration around the singularity
	for(int l = 0; l < N_LOG_QUAD_2D; l++) {
		
		// To left direction
		double local_alpha = 2*GAUSS_LOG_QUAD_POINTS[l] - 1;
		double global_alpha = s + GAUSS_LOG_QUAD_POINTS[l]*(-s-1);
		
		assert( (-1<local_alpha) && (local_alpha<1) );
		assert( (-1<global_alpha) && (global_alpha<1) );
		
		double pos[2], jac;
		position_and_jacobian_radial(local_alpha, spos, spos_left1, spos_left2, v1, pos, &jac);
		double pot_ring = callback(spos[0], spos[1], pos[0], pos[1], args);
		integration_sum += 2*jac * legendre_log_weight(k, l, global_alpha) * pot_ring;
		// To right direction
		global_alpha = s + GAUSS_LOG_QUAD_POINTS[l]*(1-s);
			
		assert( (-1<local_alpha) && (local_alpha<1) );
		assert( (-1<global_alpha) && (global_alpha<1) );
		
		position_and_jacobian_radial(local_alpha, spos, spos_right1, spos_right2, v4, pos, &jac);
		pot_ring = callback(spos[0], spos[1], pos[0], pos[1], args);
		integration_sum += 2*jac * legendre_log_weight(k, l, global_alpha) * pot_ring;
	}
	
	return integration_sum;
}

void fill_self_voltages_radial(double *matrix, 
                        vertices_2d line_points,
						uint8_t *excitation_types,
						double *excitation_values,
						size_t N_lines,
						size_t N_matrix,
                        int lines_range_start, 
                        int lines_range_end) {
	 
	for(int i = lines_range_start; i <= lines_range_end; i++) {
		
		double *v1 = &line_points[i][0][0];
		double *v2 = &line_points[i][2][0];
		double *v3 = &line_points[i][3][0];
		double *v4 = &line_points[i][1][0];
		
		enum ExcitationType type_ = excitation_types[i];
			
		if (type_ == VOLTAGE_FIXED || type_ == VOLTAGE_FUN || type_ == FLOATING_CONDUCTOR) {
			for(int l = 0; l < N_QUAD_2D; l++) 
			for(int k = 0; k < N_QUAD_2D; k++) {

				matrix[(N_QUAD_2D*i + l)*N_matrix + N_QUAD_2D*i + k] = log_integral(v1, v2, v3, v4, l, k, potential_radial_ring, NULL);
			}
		}
		else if(type_ == DIELECTRIC) {
			for(int l = 0; l < N_QUAD_2D; l++)  {
				for(int k = 0; k < N_QUAD_2D; k++) {

					double normal[2];
					higher_order_normal_radial(GAUSS_QUAD_POINTS[l], v1, v2, v3, v4, normal);
					double K = excitation_values[i];

					struct {double *normal; double K;} args = {normal, K};

					matrix[(N_QUAD_2D*i + l)*N_matrix + N_QUAD_2D*i + k] = log_integral(v1, v2, v3, v4, l, k, field_dot_normal_radial, &args);
				}
				// When working with dielectrics, the constraint is that
				// the electric field normal must sum to the surface charge.
				// The constraint is satisfied by subtracting the integral
				// over the charge from the line element.
				matrix[(N_QUAD_2D*i + l)*N_matrix + N_QUAD_2D*i + l] -= 1;
			}
		}
	}
}

EXPORT void add_floating_conductor_constraints_radial(double *matrix, vertices_2d vertices, size_t N_matrix, int64_t *indices, size_t N_indices, int row) {
	for(int j = 0; j < N_indices; j++) {
		int i = indices[j];
			
		double *v1 = &vertices[i][0][0];
		double *v2 = &vertices[i][2][0]; // Strange ordering following from GMSH line4 element
		double *v3 = &vertices[i][3][0];
		double *v4 = &vertices[i][1][0];
			
		// An extra unknown voltage is added to the matrix for every floating conductor.
		// The column related to this unknown voltage is positioned at the rightmost edge of the matrix.
		// If multiple floating conductors are present the column lives at -len(floating) + i
		for(int k = 0; k < N_QUAD_2D; k++) {
			double pos[2], jac;
			position_and_jacobian_radial(GAUSS_QUAD_POINTS[k], v1, v2, v3, v4, pos, &jac);
			
			matrix[(N_QUAD_2D*i + k)*N_matrix + N_matrix - row - 1] = -1;
			// See charge_radial function
			matrix[(N_matrix - row - 1)*N_matrix + N_QUAD_2D*i + k] = 2*M_PI*pos[0]*GAUSS_QUAD_WEIGHTS[k]*jac;
		}
	}
}



EXPORT void fill_matrix_radial(double *matrix, 
						vertices_2d line_points,
                        uint8_t *excitation_types, 
                        double *excitation_values, 
						size_t N_lines,
						size_t N_matrix,
                        int lines_range_start, 
                        int lines_range_end) {
    
	assert(lines_range_start < N_lines && lines_range_end < N_lines);
	assert(N_matrix >= N_QUAD_2D*N_lines);
		
    for (int i = lines_range_start; i <= lines_range_end; i++) {
		
		double *target_v1 = &line_points[i][0][0];
		double *target_v2 = &line_points[i][2][0];
		double *target_v3 = &line_points[i][3][0];
		double *target_v4 = &line_points[i][1][0];
		
		enum ExcitationType type_ = excitation_types[i];
			
		if (type_ == VOLTAGE_FIXED || type_ == VOLTAGE_FUN || type_ == FLOATING_CONDUCTOR) {
			for (int j = 0; j < N_lines; j++) {
				
				if (i == j) continue;
					
				double *v1 = &line_points[j][0][0];
				double *v2 = &line_points[j][2][0]; // Strange ordering following from GMSH line4 element
				double *v3 = &line_points[j][3][0];
				double *v4 = &line_points[j][1][0];
					
				for(int l = 0; l < N_QUAD_2D; l++) {
					double target[2], jac_t;
					position_and_jacobian_radial(GAUSS_QUAD_POINTS[l], target_v1, target_v2, target_v3, target_v4, target, &jac_t);
						
					for(int k = 0; k < N_QUAD_2D; k++) {
						
						double pos[2], jac;
						position_and_jacobian_radial(GAUSS_QUAD_POINTS[k], v1, v2, v3, v4, pos, &jac);
						
						matrix[(N_QUAD_2D*i + l)*N_matrix + N_QUAD_2D*j + k] = GAUSS_QUAD_WEIGHTS[k]*jac*potential_radial_ring(target[0], target[1], pos[0], pos[1], NULL);
					}
				}
			} 
		}
		else if(type_ == DIELECTRIC) {
			            
            for (int j = 0; j < N_lines; j++) {

				if(i == j) continue;
					
				double *v1 = &line_points[j][0][0];
				double *v2 = &line_points[j][2][0]; // Strange ordering following from GMSH line4 element
				double *v3 = &line_points[j][3][0];
				double *v4 = &line_points[j][1][0];
				
				for(int l = 0; l < N_QUAD_2D; l++) {
					
					double normal[2];
					higher_order_normal_radial(GAUSS_QUAD_POINTS[l], target_v1, target_v2, target_v3, target_v4, normal);
					double K = excitation_values[i];
					
					struct {double *normal; double K;} args = {normal, K};

					double target[2], jac_t;
					position_and_jacobian_radial(GAUSS_QUAD_POINTS[l], target_v1, target_v2, target_v3, target_v4, target, &jac_t);
					
					for(int k = 0; k < N_QUAD_2D; k++) {
						
						double pos[2], jac;
						position_and_jacobian_radial(GAUSS_QUAD_POINTS[k], v1, v2, v3, v4, pos, &jac);
						matrix[(N_QUAD_2D*i + l)*N_matrix + N_QUAD_2D*j + k] = GAUSS_QUAD_WEIGHTS[k]*jac*field_dot_normal_radial(target[0], target[1], pos[0], pos[1], &args);
					}
				}
            }
		}
		else {
		    printf("ExcitationType unknown");
            exit(1);
		}
	}
	
	fill_self_voltages_radial(matrix, line_points, excitation_types, excitation_values, N_lines, N_matrix, lines_range_start, lines_range_end);
}


void fill_self_voltages_3d(double *matrix, 
                        vertices_3d line_points,
						uint8_t *excitation_types,
						double *excitation_values,
						size_t N_lines,
						size_t N_matrix,
                        int lines_range_start, 
                        int lines_range_end) {

	for (int i = lines_range_start; i <= lines_range_end; i++) {
		
		double (*v)[3] = &line_points[i][0];
				
		// Target
		double t[3], jac;
		position_and_jacobian_3d(1/3., 1/3., &line_points[i][0], t, &jac);

		double s0[3], s1[3], s2[3];
		position_and_jacobian_3d(1/6., 1/6., &line_points[i][0], s0, &jac);
		position_and_jacobian_3d(4/6., 1/6., &line_points[i][0], s1, &jac);
		position_and_jacobian_3d(1/6., 4/6., &line_points[i][0], s2, &jac);
					
		triangle6 triangle1 = {
			{ t[0], t[1], t[2] },
			{ v[0][0], v[0][1], v[0][2] },
			{ v[1][0], v[1][1], v[1][2] },
			{ s0[0], s0[1], s0[2] },
			{ v[3][0], v[3][1], v[3][2] },
			{ s1[0], s1[1], s1[2] } };
		
		triangle6 triangle2 = {
			{ t[0], t[1], t[2] },
			{ v[1][0], v[1][1], v[1][2] },
			{ v[2][0], v[2][1], v[2][2] },
			{ s1[0], s1[1], s1[2] },
			{ v[4][0], v[4][1], v[4][2] },
			{ s2[0], s2[1], s2[2] } };
			
		triangle6 triangle3 = {
			{ t[0], t[1], t[2] },
			{ v[2][0], v[2][1], v[2][2] },
			{ v[0][0], v[0][1], v[0][2] },
			{ s2[0], s2[1], s2[2] },
			{ v[5][0], v[5][1], v[5][2] },
			{ s0[0], s0[1], s0[2] } };

		matrix[i*N_matrix + i] = 0.0;
		matrix[i*N_matrix + i] += triangle_integral(t, triangle1, potential_3d_point, NULL);
		matrix[i*N_matrix + i] += triangle_integral(t, triangle2, potential_3d_point, NULL);
		matrix[i*N_matrix + i] += triangle_integral(t, triangle3, potential_3d_point, NULL);
	}
}

EXPORT void fill_matrix_3d(double *matrix, 
                    vertices_3d triangle_points, 
                    uint8_t *excitation_types, 
                    double *excitation_values, 
					size_t N_lines,
					size_t N_matrix,
                    int lines_range_start, 
                    int lines_range_end) {
    
	assert(lines_range_start < N_lines && lines_range_end < N_lines);
		
    for (int i = lines_range_start; i <= lines_range_end; i++) {
		// TODO: higher order
		double target[3], jac;
		position_and_jacobian_3d(1/3., 1/3., &triangle_points[i][0], target, &jac);
			
        enum ExcitationType type_ = excitation_types[i];
		 
        if (type_ == VOLTAGE_FIXED || type_ == VOLTAGE_FUN || type_ == FLOATING_CONDUCTOR) {
            for (int j = 0; j < N_lines; j++) {
                matrix[i*N_matrix + j] = triangle_integral(target, &triangle_points[j][0], potential_3d_point, NULL);
            }
        } 
        else if (type_ == DIELECTRIC) {
			double *p1 = &triangle_points[i][0][0];
			double *p2 = &triangle_points[i][1][0];
			double *p3 = &triangle_points[i][2][0];

            double normal[3];
            normal_3d(p1, p2, p3, normal);
            double K = excitation_values[i];
            
            for (int j = 0; j < N_lines; j++) {
				// See comments in 'fill_matrix_2d'.
                double factor = (2*K - 2) / (M_PI*(1 + K));
                matrix[i*N_matrix + j] = factor * triangle_integral(target, &triangle_points[j][0], field_dot_normal_3d, normal);
				 
                if (i == j) matrix[i*N_matrix + j] -= 1.0;
            }
        }
        else {
            printf("ExcitationType unknown");
            exit(1);
        }
    }
	
	fill_self_voltages_3d(matrix, triangle_points, excitation_types, excitation_values, N_lines, N_matrix, lines_range_start, lines_range_end);
	
}

EXPORT bool
xy_plane_intersection_2d(double *positions_p, size_t N_p, double result[4], double z) {

	double (*positions)[4] = (double (*)[4]) positions_p;

	for(int i = N_p-1; i > 0; i--) {
	
		double z1 = positions[i-1][1];
		double z2 = positions[i][1];
		
		if(fmin(z1, z2) <= z && z <= fmax(z1, z2)) {
			double ratio = fabs( (z-z1)/(z1-z2) );
			
			for(int k = 0; k < 4; k++)
				result[k] = positions[i-1][k] + ratio*(positions[i][k] - positions[i-1][k]);

			return true;
		}
	}

	return false;
}

EXPORT bool
xy_plane_intersection_3d(double *positions_p, size_t N_p, double result[6], double z) {

	double (*positions)[6] = (double (*)[6]) positions_p;

	for(int i = N_p-1; i > 0; i--) {
	
		double z1 = positions[i-1][2];
		double z2 = positions[i][2];
		
		if(fmin(z1, z2) <= z && z <= fmax(z1, z2)) {
			double ratio = fabs( (z-z1)/(z1-z2) );
			
			for(int k = 0; k < 6; k++)
				result[k] = positions[i-1][k] + ratio*(positions[i][k] - positions[i-1][k]);

			return true;
		}
	}

	return false;
}










