#! /bin/env python3

import argparse

import numpy as np

from scipy.optimize import newton, brentq
import matplotlib.pyplot as plt

import traceon.geometry as G
import traceon.solver as solver
import traceon.tracing as T

parser = argparse.ArgumentParser(prog='traceon-lens-strength', description='Determine focal length of lens system')
parser.add_argument('--geometry', required=True, help='Geometry file')
parser.add_argument('--output', '-o', type=str, default=None, help='Output file to write focus positions to. Should be .npy format')
parser.add_argument('--scan-electrode', type=str, default='lens', help='Electrode on which the applied voltage is scanned over a certain range')
parser.add_argument('-V', metavar=('ELECTRODE VOLTAGE'), type=str, default=None, nargs=2, help='Extra voltages to apply on auxillary electrodes')
parser.add_argument('--voltage-range', metavar=('LOW', 'HIGH'), type=float, nargs=2, default=(-1.0, 1.5), help='Range of electrode voltages scanned')
parser.add_argument('--angle', type=float, default=0.1, help='Angle of incoming electron (mrad)')
parser.add_argument('--zmax', type=float, default=250, help='Maximum focal length to consider (mm)')
parser.add_argument('-N', type=int, default=100, help='Number of samples of voltage range')
args = parser.parse_args()

assert args.output is None or args.output.endswith('.npy')

geom = G.Geometry.read(args.geometry)
mesh = geom.mesh

energy = 1000
extra_electrode = args.V is not None
extra_electrode_args = (args.V[0],) if extra_electrode else ()
extra_voltage_args = (float(args.V[1])*energy,) if extra_electrode else ()

lines, charges, field = solver.field_function_superposition_mesh(geom, args.scan_electrode, *extra_electrode_args)

# u is defined as 2f, so z value (r=0)
# at which the electrons are reflected back
# to the same z value.
def determine_lens_strength(voltage):
    print(f'Voltage: {voltage:.2f} V/E')
    
    def distance_to_2f(u):
        position = np.array([0.0, u])
        velocity = T.velocity_vec(energy, 0.2e-3, -1)
        pos = T.trace_particle(position, velocity, field, 50.0, -args.zmax, args.zmax, args=(voltage*energy, *extra_voltage_args))
        z = T.axis_intersection(pos)
        return u+z
     
    try:
        for start in [args.zmax/10, args.zmax/5, args.zmax/2, args.zmax/1.2]:
            result = newton(distance_to_2f, args.zmax/4)
            return 2/result # f = u/2, k = 1/f = 2/u
    except IndexError:
        return 0.0
    except Exception as e:
        print('Failed to find focus: ', str(e))
        return 0.0


'''
def find_voltage_for_focal_length(f):
    u = 2*f
    vel = T.velocity_vec(energy, 0.01e-3, -1)
    
    def optimize(v):
        pos = T.trace_particle(np.array([0.0, u]), vel, field, 5, -u-1, u+1, args=(energy*v,))
        try:
            z = T.axis_intersection(pos)
        except IndexError:
            return 1000 - u
        return abs(z) - u
     
    V = brentq(optimize, 0.05, 3, xtol=1e-14)
    print(f'{f:.2f} mm, {V:.3f} V')
    return V
'''

voltages = np.linspace(args.voltage_range[0], args.voltage_range[1], args.N)
lens_strength = [determine_lens_strength(v) for v in voltages]

if args.output is not None:
    with open(args.output, 'wb') as f:
        np.save(f, np.array(voltages))
        np.save(f, np.array(lens_strength))

plt.plot(voltages, lens_strength)
plt.xlabel('Voltage (V/E)')
plt.ylabel('Lens strength (1/mm)')
plt.show()




