#! /bin/env python3

import time
import sys
import argparse
import os.path
import pickle

import matplotlib.pyplot as plt
import numpy as np
import numba as nb
from math import *
from scipy.optimize import newton
from scipy.interpolate import CubicSpline, interp1d

import traceon.geometry as G
import traceon.tracing as T
import traceon.aberrations as A
import traceon.solver as solver

parser = argparse.ArgumentParser(prog='traceon-aberration-scan', description='Find the aberrations of a geometry while scanning the voltage of one electrode and keeping the focus point the same using a focus electrode')
parser.add_argument('--geometry', required=True, nargs='*', help='Geometry files to find the aberrations curves for, for every geometry one output file will be produced')
parser.add_argument('--voltage-range', type=float, nargs=2, default=(-0.1, 2.25), help='Range of voltages applied on the scan electrode')
parser.add_argument('-N', default=50, type=int, help='Number of samples of the scan electrode voltage')
parser.add_argument('-o', '--output', default=None, help='Output file or directory to write focus positions to. The Pickle module is used to store a Python object.')
parser.add_argument('-z', type=float, nargs=2, required=True, help='Positions of crossovers with respect to the geometry.')
parser.add_argument('--focus-voltages', type=float, nargs='+', default=[-1.2, -1.75, -2.5], help='Initial focus electrode voltages to try at begin of focus optimization')
parser.add_argument('--delta-r', type=float, default=20, help='Maximum angle is chosen to cover delta-r distance at z=0 (um)')

parser.add_argument('--scan-electrode', type=str, default='lens', help='Electrode on which the applied voltage is scanned over a certain range')
parser.add_argument('--focus-electrode', type=str, default='mirror', help='Electrode on which the applied voltage should be optimized to achieve focussing')
parser.add_argument('--overwrite', action='store_true', help='Overwrite file if it already exists')
parser.add_argument('-V', type=str, default=None, nargs=2, required=False, help='Extra voltages to apply on auxillary electrodes')
args = parser.parse_args()

for geom in args.geometry:
    print('Computing for: ', geom)
    double = len(args.z) == 4

    mesh = G.Geometry.read(geom)
    energy = 1000
    
    assert args.focus_electrode in mesh.get_electrodes() and args.scan_electrode in mesh.get_electrodes()

    extra_electrode = args.V is not None
    extra_electrode_args = (args.V[0],) if extra_electrode else ()
    extra_voltage_args = (float(args.V[1])*energy,) if extra_electrode else ()
    
    z_name = 'z-' + '-'.join([f'{z:.2f}' for z in args.z])
    extra_voltage_name = f'-{args.V[0]}={float(args.V[1]):.4f}' if extra_electrode else ''

    if args.output is None or os.path.isdir(args.output):
        dir_, basename = os.path.split(geom)
        filename, extension = os.path.splitext(basename)
        out = os.path.join(dir_ if args.output is None else args.output, filename + f'-{z_name}' + extra_voltage_name + '.aberrations')
    else:
        out = args.output
    
    if os.path.isfile(out) and not args.overwrite:
        print('Skipping computation since target file already exists. Remove file to recompute or use --overwrite')
        continue
    
    _, fun = solver.field_function_superposition_mesh(mesh, args.focus_electrode, args.scan_electrode, *extra_electrode_args)
     
    if not double:
        tracer = T.PlaneTracer(fun, args.z[0], args.z[1])
    else:
        single_tracer1 = T.PlaneTracer(fun, args.z[0], args.z[1])
        single_tracer2 = T.PlaneTracer(fun, args.z[2], args.z[3])
        tracer = T.DoubleTracer(fun, fun, args.z)

    v_lens = np.linspace(args.voltage_range[0], args.voltage_range[1], args.N)
    
    def get_focus_points():
        
        def optimize(vm, vl, tracer):
            tracer.set_field_potentials(vm*energy, vl*energy, *extra_voltage_args)
            coeff, _, _ = A.spherical(tracer, energy, args.delta_r/1000)
            return coeff[1, 0]
        
        exact_zeros = []
        
        for i, vl in enumerate(v_lens):
        
            vma_approx = ([exact_zeros[-1][0]] if len(exact_zeros) else []) + args.focus_voltages
            
            for vma in vma_approx:
                if not double:
                    try:
                        exact_vm = newton(optimize, vma, args=(vl, tracer), maxiter=18)
                        print(f'Exact zero found V{args.scan_electrode.lower()}={vl:.2f}, V{args.focus_electrode.lower()}={exact_vm:.2f}')
                        exact_zeros.append([exact_vm, vl])
                        break
                    except RuntimeError as e:
                        print('Failed to converge: ', e)
                    except AssertionError as e:
                        print('Assertion error: ', e)
                else:
                    try:
                        exact_vm1 = newton(optimize, v_mirr_approx1[i], args=(vl, single_tracer1), tol=0.2e-9, maxiter=15)
                        exact_vm2 = newton(optimize, v_mirr_approx2[i], args=(vl, single_tracer2), tol=0.2e-9, maxiter=15)
                        assert (-3 <= exact_vm1 <= -1) and (-3 <= exact_vm2 <= -1)
                        print(f'Exact zero found Vlens={vl:.2f}, Vmirror1={exact_vm1:.2f}, Vmirror2={exact_vm2:.2f}')
                        exact_zeros.append([exact_vm1, vl, exact_vm2, vl])
                        break
                    except RuntimeError as e:
                        print('Failed to converge: ', e)
                    except AssertionError as e:
                        print('Assertion error: ', e)
        
        return np.array(exact_zeros)

    zeros = []
    coefficients = []
    focus_points = get_focus_points()

    for i in range(len(focus_points)):
        print('-'*25)
        try:
            if not double:
                tracer.set_field_potentials(focus_points[i, 0]*energy, focus_points[i, 1]*energy, *extra_voltage_args)
            else:
                tracer.set_field1_potentials(focus_points[i, 0]*energy, focus_points[i, 1]*energy, *extra_voltage_args)
                tracer.set_field2_potentials(focus_points[i, 2]*energy, focus_points[i, 3]*energy, *extra_voltage_args)
            
            coeff, _, _, _ = A.compute_coefficients(tracer, energy, N=6, dr=args.delta_r/1000, dE=0.05e-2)
            print(coeff)
        except Exception as e:
            print('Failed computing coefficients: ', str(e))
            continue
         
        coefficients.append(coeff.C * (-1 if double else 1))
        zeros.append(focus_points[i])

    if len(zeros) > 0:
        focus_voltages = [z[0] for z in zeros]
        scan_voltages = [z[1]  for z in zeros]
        curve = A.AberrationCurve(geom, coefficients, args.scan_electrode, args.focus_electrode, scan_voltages, focus_voltages,
            args.z, aux_electrodes=extra_electrode_args, aux_voltages=extra_voltage_args)
        curve.write(out)
    else:
        print('Not saving since no voltages with C10 = 0 where found')





